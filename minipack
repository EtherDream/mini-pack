#!/usr/bin/env node
'use strict'
const fs = require('fs')
const zlib = require('zlib')


function uleb128(num) {
  const bytes = []
  let pos = 0

  for (;;) {
    const value = num & 0x7F
    num >>>= 7
    if (num === 0) {
      bytes[pos] = value
      return bytes
    }
    bytes[pos++] = value | 0x80
  }
}

function section(code, bytes) {
  return [
    code,
    ...uleb128(bytes.length),
    ...bytes,
  ]
}

const dataBuf = fs.readFileSync(0)
const dataLen = dataBuf.length
const pageNum = Math.ceil(dataLen / 65536)

const exportName = Buffer.from(dataLen + '')

const wasmBuf = Buffer.from([
  0x00, 0x61, 0x73, 0x6D, // magic
  0x01, 0x00, 0x00, 0x00, // version

  ...section(0x05, [      // [Linear-Memory Section]
    0x01,                 // num memories
    0x00,                 // limits: flags (initial only)
    ...uleb128(pageNum),  // limits: initial
  ]),

  ...section(0x07, [      // [Export Section]
    0x01,                 // num exports
    exportName.length,    // string length (<127)
    ...exportName,        // export name
    0x02,                 // export kind (Memory)
    0x00,                 // export memory index
  ]),

  ...section(0x0B, [      // [Data Section]
    0x01,                 // num data segments
    0x00,                 // segment flags
    0x41,                 // i32.const
    0x00,                 // i32 literal
    0x0B,                 // end
    ...uleb128(dataLen),  // data segment size
    ...dataBuf,
  ]),
])

const outBuf = zlib.brotliCompressSync(wasmBuf, {
  params: {
    [zlib.constants.BROTLI_PARAM_QUALITY]: zlib.constants.BROTLI_MAX_QUALITY,
  }
})
process.stdout.write(outBuf)

const saving = 1 - outBuf.length / dataLen

console.error('[minipack]',
  'in:', dataLen,
  'out:', outBuf.length,
  'saving:', (saving * 100).toFixed(2) + '%'
)